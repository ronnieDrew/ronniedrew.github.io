<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Azure | Brewing Code]]></title>
  <link href="http://www.brewingcode.com/blog/categories/azure/atom.xml" rel="self"/>
  <link href="http://www.brewingcode.com/"/>
  <updated>2013-12-13T15:05:21+00:00</updated>
  <id>http://www.brewingcode.com/</id>
  <author>
    <name><![CDATA[Ronan Gibney]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Windows Azure Table Explorer]]></title>
    <link href="http://www.brewingcode.com/blog/2013/08/10/windows-azure-table-explorer/"/>
    <updated>2013-08-10T09:04:00+01:00</updated>
    <id>http://www.brewingcode.com/blog/2013/08/10/windows-azure-table-explorer</id>
    <content type="html"><![CDATA[<p>This morning I was reading back over the archives of Jeff Wilcox's blog and came across <a href="http://www.jeff.wilcox.name/2013/04/windows-azure-table-explorer/">this post</a> detailing a Single Page App that he built for browsing table service data on an Azure storage account.</p>

<p>As I've been learning <a href="http://emberjs.com/">Ember</a> I thought it would be fun to take the jQuery front end and replace it with Ember.</p>

<!--more-->


<h3>Overview</h3>

<p>So first thing I'll just do a quick run through Jeff's application as it stands (you can find the GitHub repo <a href="https://github.com/jeffwilcox/azure-table-explorer">here</a>).</p>

<p>The application is up and running on Azure websites here <a href="https://waztable.azurewebsites.net/">https://waztable.azurewebsites.net/</a> and allows you to browse the Table Service data for a particular Storage Account.</p>

<p>Jeff is using the <a href="https://github.com/WindowsAzure/azure-sdk-for-node">Windows Azure SDK for Node</a> to build a simple API in Node for his client side app. All requests to this API need to provide credentials which are the storage account name and access key, invalid credentials are rejected with a HTTP 401 error.</p>

<p><code>GET /json/table/?account={storage-account}&amp;key={storage-key}</code> - returns a list of tables defined on the storage account.
``` json Response
{
  "ok":true,
  "result":{</p>

<pre><code>"tables":["logs","people"],
"name":"brewingcode"
</code></pre>

<p>  }
}
```</p>

<p><code>GET /json/table/{table-name}?account={storage-account}&amp;key={storage-key}&amp;top={results-per-page}&amp;nextPartitionKey={partition-key}&amp;nextRowKey={row-key}</code> - returns a number of records specified by the <code>top</code> parameter for the specified table. If more records are available a continuation token will also be returned, this can the be used in subsequent requests to page through remaining records via the optional <code>nextPartitionKey</code> &amp; <code>nextRowKey</code> parameters.
``` json Response
{
  "ok":true,
  "table":{</p>

<pre><code>"continuation":{"nextPartitionKey":"1!8!bG9ncw--","nextRowKey":"1!4!Mjc-"},
"rows":[
  {
    "_":{
      "id":"https://brewingcode.table.core.windows.net/logs(PartitionKey='logs',RowKey='18')",
      "link":"logs(PartitionKey='logs',RowKey='18')",
      "updated":"2013-12-05T15:26:07Z",
      "etag":"W/\"datetime'2013-11-18T16%3A09%3A20.1183355Z'\""},
      "PartitionKey":"logs",
      "RowKey":"18",
      "Timestamp":"2013-11-18T16:09:20.118Z",
      "Level":"info",
      "Message":"Message - 18"
    },
    // ...
]
</code></pre>

<p>  }
}
```</p>

<p><code>DELETE /json/table/{table-name}/{partition-key}/{row-key}?account={storage-account}&amp;key={storage-key}</code> - deletes the specified row from the table.
``` json Response
{
  "ok":true,
  "response":{</p>

<pre><code>"isSuccessful":true,
"statusCode":204,
"headers":{
  // ...
}
</code></pre>

<p>  }
}
```</p>

<h2>Front end</h2>

<p>The UI itself is very simple and consists of the following pages.</p>

<p>First we have the login/credentials page where you enter your storage account name and access key.</p>

<p><img src="/images/posts/2013-08-06-windows-azure-table-explorer/credentials-page.png" alt="Credentials page" /></p>

<p>If you've provided valid credentials then you'll see a listing of all the tables defined in the specified storage account.</p>

<p><img src="/images/posts/2013-08-06-windows-azure-table-explorer/storage-account-tables.png" alt="Storage Account table listing" /></p>

<p>Finally you can then select and view table data as seen below. Multiple rows can be selected which activates a master/detail view and the option to delete the selection items as seen in the 2nd screen shot.</p>

<p><img src="/images/posts/2013-08-06-windows-azure-table-explorer/table-listing.png" alt="Storage Account table listing" /></p>

<p><img src="/images/posts/2013-08-06-windows-azure-table-explorer/table-list-with-selected-items.png" alt="Storage Account table listing with multiple items selected" /></p>

<h2>Ember Tooling</h2>

<p>Before we get into converting this into Ember we need to talk a little about tooling. If you're building an application with Ember then you're going to need to have some kind of tooling/build process in place. At the moment I like to use <a href="http://yeoman.io">Yeoman</a> for this.</p>

<p>For those of you have haven't heard of it before Yeoman is a collection of <a href="http://gruntjs.com/">Grunt</a> build scripts, <a href="https://github.com/yeoman/yo">scaffolding tools</a>, Twitters <a href="http://bower.io/">Bower</a> package manager and a bunch of opinion.</p>

<p>On Windows assuming you have <a href="http://chocolatey.org/">Chocolatey</a> installed (and if not why not?) then getting Yeoman installed is as simple as...</p>

<p><code>powershell
cinst Yeoman
</code></p>

<p>With Yeoman installed next we'll want to add the scaffolding support for the Ember tools.</p>

<p><code>powershell
npm install -g generator-ember
</code></p>

<p>With that we'll create a directory for our app and use the Yeoman scaffolding tools for Ember to create a basic structure.</p>

<p><code>powershell
mkdir emberapp
cd emberapp
yo ember
</code></p>

<p>This will create the directory structure seen below.</p>

<p><img src="/images/posts/2013-08-06-windows-azure-table-explorer/yeoman-directory-structure.png" alt="Yeoman directory structure" /></p>

<p>The files/directories in the root directory to call out are.</p>

<ul>
<li><code>bower.json</code> - a list of packages from Bower that we are using in our app.</li>
<li><code>Grunt.js</code> - the Grunt file contains the build scripts for our application, specifically we'll be using the following commands.

<ul>
<li><code>grunt server</code> - runs your application in preview mode at <code>http://localhost:4000</code>. The file system is monitored for changes and the application is re-built as required.</li>
<li><code>grunt test</code> - runs your application unit tests inside <a href="http://phantomjs.org">PhantomJS</a></li>
<li><code>grunt</code> - builds the application in release mode and ready for deployment, the output of this task is created in the <code>dist</code> directory.</li>
</ul>
</li>
<li><code>packages.json</code> - a list of the npm packages required by Yeoman.</li>
<li><code>.\app</code> - contains the source code for the Ember application.</li>
<li><code>.\dist</code> - when the application is built in release mode the output of the task will be copied to this directory.</li>
<li><code>.\test</code> - contains your unit tests for the application.</li>
</ul>


<p>Before we use <code>npm install</code> to get all the required node modules for our application we need to make a small alternation to the <code>packages.json</code> that was just created the <code>emberapp</code> directory. There is problem with the <code>grunt-contrib-imagemin</code> module on Windows. It depends on <code>jpegtran-bin</code> and the latest version of this can't be built from source on Windows and thus installed via npm. Instead we can specify the previous version in the <code>package.json</code>, this should be above <code>grunt-contrib-imagemin</code>.</p>

<p>``` json packages.json</p>

<pre><code>// ...
"jpegtran-bin": "0.2.0",
"grunt-contrib-imagemin": "~0.2.0",
// ...
</code></pre>

<p>```</p>

<p>With this alteration in place you can go ahead and run <code>npm install</code> to get all the required dependencies.</p>

<p>So at this point we will have the basic structure of our Ember app scaffolded out and everything is ready to be built and run. We can boot the app with the <code>grunt server</code> command, this will run the app on <code>http://localhost:4000</code>.</p>

<h3>Ember Concepts</h3>

<p>Now we are ready to start building out the app however before that I'll just do a super quick run down through the main components in Ember.</p>

<ul>
<li><code>Router</code> - Used to define routes for your application. In Ember URLs contain the state required for the Router to create a corresponding set of Controllers, Routes &amp; Templates that are needed to restore the app to the point defined by the URL.</li>
<li><code>Routes</code> - a Route is responsible for loading a model and rendering a template into an outlet.</li>
<li><code>Model</code> - a Model holds data that is persisted on the server, in our case Models will be created from the JSON returned by the API defined at the top of the post.</li>
<li><code>Controller</code> - a Controller proxies it's related model and can be used to add any UI specific properties or functionality required. Coming from a XAML background I like to think of Ember Controllers as what we would call a ViewModel in XAML world.</li>
<li><code>Template</code> - Ember uses the <a href="http://handlebarsjs.com/">Handlebars</a> templating language. A Template is bound to a Controller and is responsible for rendering UI for a specific portion of the page which is known as an Outlet. Templates can also contain Outlets so you can easily build your UI with multiple templates nested within each other.</li>
<li><code>View</code> - in Ember Views are used when you need more control over exactly how the DOM is manipulated, typically they are quite useful when integrating with other libraries such as jQuery plugins.</li>
</ul>


<p>Finally we'll have a quick look at the <code>.\app</code> directory which contains the source for our Ember application.</p>

<p><img src="/images/posts/2013-08-06-windows-azure-table-explorer/ember-app-structure.png" alt="Ember application directory structure" /></p>

<ul>
<li><code>.\bower_components</code> - packages referenced in bower.json are stored in this directory.</li>
<li><code>.\img</code> - We're using Bootstrap so this directory contains some glyphicon image files.</li>
<li><code>.\scripts</code> - the JavaScript source. In the root we have a file app.js which is the application entry point, after that we have separate sub-directories for our various Ember components e.g. controllers, models, routes &amp; views.</li>
<li><code>.\styles</code> - contains the SASS source used to produce our CSS.</li>
<li><code>.\templates</code> - Handlebars templates</li>
<li><code>index.html</code> - the container for our Ember application.</li>
</ul>


<p>An excerpt of the index.html file is listed below, the important parts are the <code>build:js</code> snippets. Yeoman uses these markers to insert Bower libraries, Handlebars templates and the application source itself. Depending on the grunt task executed what's injected into these placeholders will be different, for example when running <code>grunt</code> the application is built in release mode and so files are concatenated, minified &amp; uglified.</p>

<p>``` html index.html
&lt;!DOCTYPE html></p>

<pre><code>// ...
&lt;body&gt;
    &lt;!-- build:js scripts/components.js --&gt;
    &lt;script src="bower_components/jquery/jquery.js"&gt;&lt;/script&gt;
    &lt;script src="bower_components/momentjs/moment.js"&gt;&lt;/script&gt;        
    &lt;script src="bower_components/underscore/underscore.js"&gt;&lt;/script&gt;
    &lt;script src="bower_components/handlebars/handlebars.runtime.js"&gt;&lt;/script&gt;
    &lt;script src="bower_components/ember/ember.js"&gt;&lt;/script&gt;
    &lt;!-- endbuild --&gt;

    &lt;!-- build:js(.tmp) scripts/templates.js --&gt;
    &lt;script src="scripts/compiled-templates.js"&gt;&lt;/script&gt;
    &lt;!-- endbuild --&gt;

    &lt;!-- build:js(.tmp) scripts/main.js --&gt;
    &lt;script src="scripts/combined-scripts.js"&gt;&lt;/script&gt;
    &lt;!-- endbuild --&gt;

    &lt;!-- build:js scripts/plugins.js --&gt;
    &lt;script src="bower_components/bootstrap-sass/js/bootstrap-affix.js"&gt;&lt;/script&gt;
    &lt;script src="bower_components/bootstrap-sass/js/bootstrap-alert.js"&gt;&lt;/script&gt;
    // ...
    &lt;!-- endbuild --&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<h2>Replacing jQuery with Ember</h2>

<p>The first thing you want to do when starting an Ember app is to get your routes defined. Below are the route definitions for the app, I've also included comments for routes that Ember will create by itself. Ember is a very convention based framework and in particular route names are important as these are used in the controller, model, route &amp; template naming conventions.</p>

<p>``` javascript Application Routes
App.Router.map(function () {</p>

<p>  // application
  // index</p>

<p>  this.resource("tables", function() {</p>

<pre><code>// tables.index

this.resource("table", { path: ":table_id" }, function() {
  // table.index

  this.route("page", { path: ":page_id" } );
});
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>With these routes defined we can start fleshing out the templates and layout of our application. The <code>application.hbs</code> template will be rendered by Ember when your application starts so it's the place to define your page layout structure. The header and footer sections have been created as separate template fragments <code><em>header.hbs</code> and <code></em>footer.hbs</code> and are included using the <code>{{partial "{template-name}"}}</code> helper. Note that partial templates must always be named with an underscore prefix however this prefix is excluded when using the partial helper. e.g. A partial template <code>_header.hbs</code> is included in a template using <code>{{partial "header"}}</code>. Also the binding context of the partial is not changed, the fragment is just treated as if it were inline with the main template.</p>

<p>Along with partials we also have two outlets defined in this template. Outlets are just placeholders that other templates can be rendered into. Templates can have a single default outlet which is not given a name, if a template has multiple outlets then the non-default items must be allocated unique names. In this case we have a separate outlet for modal dialogs which will be covered later in the post.</p>

<p>
``` html application.hbs
{{partial "header"}}</p>

<div class="container">

    {{outlet}}

    <hr/>

    {{partial "footer"}}

</div>


<p>{{outlet "modalOutlet"}}
```
</p>

<p>The next default template that Ember will render is the <code>index.hbs</code> template. As we want the landing page of our application to be the credentials/login screen we will create an <code>IndexController</code> that will be bound to this template and control the credentials/login process.</p>

<p>``` javascript IndexController.js
App.IndexController = Ember.ObjectController.extend({</p>

<pre><code>storageAccount: "",
storageKey: "",
attemptedTransition: null,
credentials: null,

usingSSL: function() {
    return (document.location.protocol === "https:");
}.property(),

loginDisabled: function() {
    var credentials = this.getProperties("storageAccount", "storageKey");

    if (credentials.storageAccount.length &gt; 0 &amp;&amp; credentials.storageKey.length &gt; 0 ) {
        return false;
    }

    return true;

}.property("storageAccount", "storageKey"),

login: function() {
    var self = this,
        credentials = this.getProperties("storageAccount", "storageKey"),
        attemptedTransition = this.get("attemptedTransition"),
        tables = App.Tables.find(credentials);

    tables.then(function(data) {
        // success
        self.set("credentials", credentials);

        if (attemptedTransition) {
            attemptedTransition.retry();
            self.set("attemptedTransition", null);
        } else {
            self.transitionToRoute("tables.index");
        }

    }, function(reason) {
        // failure
        self.set("credentials", null);
        self.send("error", reason);
    });

}
</code></pre>

<p>});
```</p>

<ul>
<li><code>storageAccount</code> - bound to the corresponding input element in the template.</li>
<li><code>storageKey</code> - as above.</li>
<li><code>attemptedTransition</code> - route transitions can be cancelled if the application doesn't have valid credentials. If this is the case the application will redirect back to the index route and store the originally attempted route transition here. If the credentials/login is successful we can then retry the original transition and return the app to the requested URL.</li>
<li><code>credentials</code> - If the supplied <code>storageAccount</code> and <code>storageKey</code> are valid then these credentials will be stored here and used for subsequent API requests throughout the app.</li>
<li><code>usingSSL</code> - true/false depending on whether the page is using SSL. This is used to toggle the warning message within the template that is displayed if the page is not using SSL.</li>
<li><code>loginDisabled</code> - toggles whether the "Explore" button is enabled/disabled. This is a computed field and is dependent on the <code>storageAccount</code> &amp; <code>storageKey</code> fields, if either field is empty then the button is disabled.</li>
<li><code>login</code> - handles the click action of the "Explore" button. This action will use the method <code>App.Tables.find</code> passing the credentials entered by the user, this returns a promise &amp; when it resolves successfully we will store the credentials and redirect to the appropriate route. If the promise resolves with an error then credentials are cleared and we send an error message. This will eventually bubble up to the <code>ApplicationRoute</code> which will in turn trigger a modal dialog to display an error message.</li>
</ul>


<p>Below is the template that will be bound to the <code>IndexController</code>. What we are doing here is binding some CSS classes to corresponding properties on the controller using the <code>{{bindAttr}}</code> helper. This helper can be used to bind any element attribute to a corresponding property on the controller.</p>

<p>We then use the <code>Ember.TextField</code> view to create a text and password type input fields and bind them to the storageAccount and storageKey fields on the controller.</p>

<p>Finally the click action on the "Explore" button is set to be handled by the <code>login</code> function on our controller.</p>

<p>
``` html index.hbs</p>

<div id="credentials" class="hero-unit">
  <h1>Explore a storage account</h1>
  
  <div id="nossl" {{bindAttr class=":alert :alert-block usingSSL:hide:show"}}>
    <h4>Security Warning!</h4>
    <p>You are not currently browsing this site through an encrypted SSL session. If you submit your 
    Windows Azure storage account name and access key, this information will be sent over the 
    wire unencrypted. Don't do it. Please.</p>
  </div>

  <p id="ssl" {{bindAttr class="usingSSL:show:hide"}}>
    You're using an SSL connection with this cloud service - your credentials will be transmitted securely. The credentials are sent with every dynamic request and immediately destroyed.
  </p>

  <p>
    {{view Ember.TextField valueBinding="storageAccount" placeholder="Storage account" class="span5"}}
  </p>

  <div class="input-prepend">
    <span class="add-on"><i class="icon-lock"></i></span>
    {{view Ember.TextField valueBinding="storageKey" placeholder="Access account" type="password" class="span5"}}
  </div>
  
  <p>
    <button class="btn btn-primary" {{action login}} {{bindAttr disabled="loginDisabled"}} id="setCredentials">Explore &raquo;</button> 
    <a href="https://github.com/jeffwilcox/azure-table-explorer" class="btn" target="_blank">App source &raquo;</a>
  </p>
</div>


<p>```
</p>

<h4>Models</h4>

<p>In order to build out the rest of the application we'll need to go ahead and create the various models that we will need we are..</p>

<ul>
<li><code>Tables</code> - storage account details and a list of associated tables.</li>
<li><code>Table</code> - table id and a list of continuation tokens that are required for pagination.</li>
<li><code>Page</code> - A set of rows for a particular table.</li>
<li><code>Row</code> - A individual table record.</li>
</ul>


<p>As we are not using Ember Data we'll just extend <code>Ember.Object</code> when creating our models. The <code>Ember.Object.extend</code> method is used to define properties for each model, once defined an instance of the <code>Tables</code> model can be created using the <code>App.Tables.create</code> method. The <code>reopenClass</code> method can be used to add static properties and methods to the model.</p>

<p>``` javascript Tables.js
App.Tables = Ember.Object.extend({</p>

<pre><code>id: null,
tables: null
</code></pre>

<p>});</p>

<p>App.Tables.reopenClass({
  find: function(credentials) {</p>

<pre><code>var requestData = {
  account: credentials.storageKey ? credentials.storageAccount : undefined,
  key: credentials.storageKey,
  top: 10
};

return Ember.RSVP.Promise(function(resolve, reject) {

    App.ajax("/json/table", {data: requestData}).then(function(value) {
      // success
      resolve(
        App.Tables.create({
          id: value.result.name,
          tables: _.map(value.result.tables, function(item) {
            return App.Table.create({id: item});
          })
        })
      );
    }, function(error) {
      // fail
      reject(error);
    });

});
</code></pre>

<p>  }
});
```
* <code>id</code> - the storage account name.
* <code>tables</code> - a list of <code>App.Table</code> objects.
* <code>find</code> - uses an internal Ajax helper to make the API request, this helper returns a promise. The <code>find</code> method itself returns a promise that wraps that returned by the ajax helper, when the ajax promise resolves the JSON response is unpacked and converted into an <code>App.Tables</code> instance.</p>

<p>``` javascript Table.js
App.Table = Ember.Object.extend({</p>

<pre><code>id: null,
</code></pre>

<p>  continuationTokens: null
});
```
* <code>id</code> - the table name, this is unique within the storage account.
* <code>continuationTokens</code> - a list of continuation tokens that are required for pagination. This will be covered in more detail later in the post.</p>

<p>``` javascript Page.js
App.Page = Ember.Object.extend({</p>

<pre><code>id: null,
continuation: null,
rows: null
</code></pre>

<p>});</p>

<p>App.Page.reopenClass({
  find: function(tableName, credentials, pageId, continuation) {</p>

<pre><code>var partitionKey,
  requestData = {
  account: credentials.storageKey ? credentials.storageAccount : undefined,
  key: credentials.storageKey,
  top: 10
};

// ...
</code></pre>

<p>  }
});
```
* <code>id</code> - the page number.
* <code>continuation</code> - if more results are available after the current page then this will contain the continuation token returned by Azure.
* <code>rows</code> - a list of <code>App.Row</code> instances that make up the page results.
* <code>find</code> - as with <code>App.Tables.find</code> this returns a promise that will eventually resolve to return an instance of an <code>App.Page</code> model.</p>

<p>``` javascript Row.js
App.Row = Ember.Object.extend({</p>

<pre><code>id: null,
PartitionKey: null,
RowKey: null,
isSelected: false,
partitionKeyChanged: false
</code></pre>

<p>});
```
* <code>id</code> - a unique id for the row, this is a combination of the <code>PartitionKey</code> &amp; <code>RowKey</code>.
* <code>PartitionKey</code> - the Azure table service partition key.
* <code>RowKey</code> - the Azure table service row key.
* <code>isSelected</code> - this probably shouldn't be a property on the model, it's used to toggle the selection status of rows within the table.
* <code>partitionKeyChanged</code> - as above this property is used when rendering the table, when the partition key is different from the previous row a new partition key header is rendered.</p>

<h4>Authentication</h4>

<p>In order to use the application a valid set of credentials needs to be defined. Outside of the login/landing page none of the other routes should be accessible without valid credentials, instead we just want to redirect back to the login page. If valid credentials are subsequently entered we can then redirect back to the original route that was requested.</p>

<p>This is easy to do in Ember, what we can do is define an <code>AuthenticatedRoute</code> as seen below and have all the routes that require credentials extend from this.</p>

<p>We can use the <code>beforeModel</code> hook on the route which allows us to cancel the current route transition and redirect elsewhere. In the <code>_redirectToLogin</code> function we grab an instance of the <code>index</code> controller and then set the currently attempted route transition before redirecting the index route itself. This allows us to redirect back to the original requested route if needed.</p>

<p>Finally we can use the <code>events</code> hash to define an event handler for any errors that bubble up to the route. The Node API will throw a HTTP 401 Unauthorized error for any requests with invalid credentials, in this case we can also just redirect back to the login page. For any other errors we will just re-throw the error which will eventually be handled by the <code>Application</code> route.</p>

<p>``` javascript AuthenticatedRoute.js
App.AuthenticatedRoute = Ember.Route.extend({</p>

<pre><code>credentials: null,

_redirectToLogin: function(transition) {
    var indexController = this.controllerFor("index");

    indexController.set("attemptedTransition", transition);
    this.transitionTo("index");
},

beforeModel: function(transition) {
    var credentials = this.controllerFor("index").get("credentials");

    if (!credentials) {
        this._redirectToLogin(transition);
    } else {
        this.set("credentials", credentials);
    }
},

events: {
    error: function(reason, transition) {
        if (reason.status === 401) {
            this._redirectToLogin(transition);
        } else {
            throw {error: reason, transition: transition};
        }
    }
}
</code></pre>

<p>});
```</p>

<p>``` javascript ApplicationRoute.js
App.ApplicationRoute = Ember.Route.extend({</p>

<p>  events: {</p>

<pre><code>error: function(error) {
  var errorController = this.router.container.lookup("controller:error");

  errorController.set("model", error);

  this.render("errorModal", {
    into: "application",
    outlet: "modalOutlet",
    controller: errorController
  });
},

closeModal: function() {
  this.render("emptyTemplate", {
    into: "application",
    outlet: "modalOutlet"
  });
}
</code></pre>

<p>  }</p>

<p>});
```
* <code>events</code> - in <code>ApplicationRoute</code> the <code>events</code> hash lets us define application wide handlers for certain items. For example in <code>BootstrapModalView</code> we trigger a <code>closeModal</code> event, this will then bubble up through the corresponding <code>Controller</code>, <code>Route</code> and finally <code>ApplicationRoute</code> until it is handled.
* <code>error</code> - used to provide an application wide hook for any unhandled errors, once an error is caught a modal dialog is displayed.
* <code>closeModal</code> - closes the currently opened modal dialog, to do this we just render an empty template into the modal outlet.</p>

<h4>Modal Dialogs</h4>

<p>We are using the Bootstrap modal dialog to display errors that occur in the application. When we want to use other libraries that manipulate the DOM we need to do a little bit of work to ensure that whatever we are using doesn't step on Embers toes and interfere with its rendering.</p>

<p>Typically what you'll end up doing is creating a <code>View</code> which wraps the library/plugin you are using. A <code>View</code> contains two import hooks which are <code>didInsertElement</code> and <code>willDestroyElement</code>. From Embers perspective a <code>View</code> is represented by a single DOM element and after this has been inserted into the DOM it will call <code>didInsertElement</code>. We can use this hook to create an instance of the Bootstrap Modal dialog plugin, render it within our container DOM element and hook up any events to corresponding handlers within the view.</p>

<p>``` javascript BootstrapModalView.js
App.BootstrapModalView = Ember.View.extend({
  layoutName: "modal_layout",</p>

<p>  backdrop: true,
  keyboard: true,
  backdropClass: "",
  positionSelector: null,
  position: "bottom",</p>

<p>  didInsertElement: function() {</p>

<pre><code>var controller = this.get("controller"),
  pos, tp, actualWidth, actualHeight;

this.$(".modal").modal({
  dynamic: true,
  keyboard: this.get("keyboard"),
  backdropClass: this.get("backdropClass")
});

this.$(".modal").one("hidden", function() {
  if (controller) {
    controller.send("closeModal");
  }
});

// Dialog placement code
// ...
</code></pre>

<p>  },</p>

<p>  close: function() {</p>

<pre><code>this.$(".modal").modal("hide");

this.get("controller").send("closeModal");
</code></pre>

<p>  }
});
```
* <code>layoutName</code> - a layout template can be specified, in our case <code>modal_layout</code> is simply a <code>DIV</code> with its css class set to <code>modal</code>. The <code>{{yield}}</code> keyword is a placeholder that indicates where the view will be rendered within the layout template.
* <code>backdrop</code> - true/false, sets whether dialog should include a backdrop element.
* <code>keyboard</code> - true/false, closes the modal when the escape key is pressed.
* <code>backdropClass</code> - the css class of the backdrop element.
* <code>positionSelector</code> - the dialog can be displayed relative to another element, this should be a selector expression.
* <code>position</code> - if position relative to another element this should be one of top, right, bottom or left.
* <code>didInsertElement</code> - creates an instance of the Bootstrap Modal dialog plugin.
* <code>close</code> - the <code>errorModal.hbs</code> template triggers this action when it's close button is clicked. We in turn trigger a <code>closeModal</code> which will eventually be handled by the application route.</p>

<p>This view can then be simply used as seen below in the <code>errorModal.hbs</code> template.

``` html errorModal.hbs
{{#view App.BootstrapModalView backdropClass="modal-backdrop-transparent"}}
  <div class="modal-header"></p>

<pre><code>  &lt;button type="button" class="close" {{action close target="view"}}&gt;&amp;times;&lt;/button&gt;

  &lt;h3 id="modal_error_subject"&gt;Error&lt;/h3&gt;
</code></pre>

<p>  </div></p>

<p>  <div class="modal-body"></p>

<pre><code>&lt;p id="modal_error_text"&gt;Whoops, something has gone wrong!&lt;/p&gt;
</code></pre>

<p>  </div></p>

<p>  <div class="modal-footer"></p>

<pre><code>&lt;a class="btn" {{action close target="view"}}&gt;Close&lt;/a&gt;
</code></pre>

<p>  </div>
{{/view}}
```
</p>

<h4>Table list</h4>

<p>With authentication and the modal dialog support in place we can move on to the next page that is required after entering in storage account credentials which is the table listing.</p>

<p>This simply displays a list of the tables that are associated with the storage account.</p>

<p>``` javascript TablesRoute.js
App.TablesRoute = App.AuthenticatedRoute.extend({
  model: function() {</p>

<pre><code>return App.Tables.find(this.get("credentials"));
</code></pre>

<p>  }
});
```
* <code>model</code> - as we extend from <code>AuthenticatedRoute</code> we have the users storage account credentials available, we then make a call to the JSON API to retrieve a list of tables defined for the account. As we haven't defined a controller Ember will automatically create one, set the model &amp; bind it to the corresponding template.</p>

<p>
``` html tables.hbs</p>

<div class="row">
  <div class="span9" id="results">
    {{outlet}}
  </div>

  <div class="span3">
    <h1 id="accountName">{{storageAccountName}}</h1>

    <div id="tableList">
      <ul class="nav nav-list">
        <li class="nav-header">Tables</li>
      {{#each table in tables}}
        <li>
          {{#linkTo table.page table App.Page.FIRSTPAGE}}
            {{table.id}}
          {{/linkTo}}
        </li>
      {{else}}
        <li>No tables defined for this storage account.</li>
      {{/each}}
      </ul>     
    </div>
  
    <div id="rowDetails">
      {{outlet "selectedRowsOutlet"}}
    </div>
  </div>
</div>


<p>```
* <code>outlet</code> - before a table is selected the <code>tables/index.hbs</code> template will be rendered into this outlet.
* <code>storageAccountName</code> - the storage account name.
* <code>{{#each table in tables}}</code> - renders a list of tables that are defined in the storage account, the <code>linkTo</code> helper creates links to the first page of records for the selected table.
* <code>selectedRowsOutlet</code> - by default nothing is rendered into this template. It is populated once the user has navigated to a particular table and has selected records. The template <code>table/selectedRows.hbs</code> will then be rendered into this outlet.
</p>

<p>When first loaded Ember will render <code>tables/index.hbs</code> into the default <code>outlet</code> of the <code>tables.hbs</code> template. Once the user selects a table to view the table results will be rendered into the outlet instead.
``` html tables/index.hbs</p>

<h2>Get started.</h2>


<p>Please select a table on the side to get started.</p>


<p>```</p>

<h4>Pagination</h4>

<p>When a table is selected the application will navigate to the first page of results, if more results are available then the Azure storage API will include what is known as a continuation token. The continuation token is made up of a partition key and a row key and must be included in the subsequent request in order to obtain the next set of results.</p>

<p>``` javascript TablePageRoute.js
App.TablePageRoute = App.AuthenticatedRoute.extend({
  renderTemplate: function() {</p>

<pre><code>var selectedRowsController = this.controllerFor("selectedRows");
this.render();

this.render("table/selectedRows", {
  into: "tables",
  outlet: "selectedRowsOutlet",
  controller: selectedRowsController
});
</code></pre>

<p>  },</p>

<p>  setupController: function(controller, model) {</p>

<pre><code>var self = this,
  pageId = model.id,
  tableId = this.modelFor("table").get("id"),
  credentials = this.get("credentials"),
  continuation = this._getPageContinuationToken(pageId - 1);

if (!model.rows) {
  model = App.Page.find(tableId, credentials, pageId, continuation);

  model.then(function(value) {
    // success
    self._setPageContinuationToken(value.id, value.continuation);
    controller.set("model", value);
  }, function(error) {
    // failure
    throw error;
  });
}
</code></pre>

<p>  },</p>

<p>  model: function(params) {</p>

<pre><code>var pageId = parseInt(params.page_id, 10) || 1;

return App.Page.create({id: pageId});
</code></pre>

<p>  },</p>

<p>  _getPageContinuationToken: function(pageId) {</p>

<pre><code>var continuationToken = null,
  table = this.modelFor("table"),
  continuationTokens = table.get("continuationTokens");

if (continuationTokens) {
  continuationToken =  continuationTokens[pageId];
}

return continuationToken;
</code></pre>

<p>  },</p>

<p>  _setPageContinuationToken: function(pageId, continuationToken) {</p>

<pre><code>var table = this.modelFor("table"),
  continuationTokens = table.get("continuationTokens");

if (!continuationTokens) {
  continuationTokens = {};
  table.set("continuationTokens", continuationTokens);
}

continuationTokens[pageId] = continuationToken;
</code></pre>

<p>  }
});
```
* <code>renderTemplate</code> - this renders not only the default template but also the <code>table/selectedRows</code> template.
* <code>setupController</code> - this hook is called after the <code>model</code> hook, here we check if the model is fully loaded, if not we get the current continuation token and request the detailed results for the current page.
* <code>model</code> - returns an instance of <code>Page</code> with only the <code>id</code> property set, the model will be fully loaded in <code>setupController</code>.
* <code><em>getPageContinuationToken</code> - gets the current <code>Table</code> and loads the continuation token for the current page of results.
* <code></em>setPageContinuationToken</code> - stores a continuation token for a given page on the <code>Table</code> model instance.</p>

<p>``` javascript TablePageController.js
App.TablePageController = Ember.ObjectController.extend({
  toggleRowSelection: function(row) {</p>

<pre><code>var isSelected = row.get("isSelected") || false;

row.set("isSelected", !isSelected);
</code></pre>

<p>  },</p>

<p>  columns: function() {</p>

<pre><code>var columns = [],
  excludedColumns = {
    id: true,
    PartitionKey: true,
    RowKey: true,
    isSelected: true,
    partitionKeyChanged: true,
    _: true
  };

_.each(this.get("rows"), function(element) {
  for(var column in element) {
    if (!element.hasOwnProperty(column)) {
      break;
    }

    if (!excludedColumns[column] &amp;&amp; _.contains(columns, column) !== true) {
      columns.push(column);
    }
  }
});

return columns;
</code></pre>

<p>  }.property("rows.@each"),</p>

<p>  columnHeaders: function() {</p>

<pre><code>var columnHeaders = _.clone(this.get("columns"));

// blank header for "isSelected" column
columnHeaders.unshift(" ");

return columnHeaders;
</code></pre>

<p>  }.property("columns"),</p>

<p>  paginationLinks: function() {</p>

<pre><code>var links = [],
  currentPage = this.get("id"),
  startPage = (currentPage &gt; 5) ? (currentPage - 5) : 1,
  endPage = currentPage;

endPage += this.get("continuation") ? 2 : 1;

// Create a list of App.Page objects
// ...

return links;
</code></pre>

<p>  }.property("id")
});
```
* <code>toggleRowSelection</code> - toggles the <code>isSelected</code> property for a given row.
* <code>columns</code> - returns a list of columns that will be displayed in the results table. A common set of properties are excluded from this list.
* <code>columnHeaders</code> - returns a list of column headers that are displayed in the results table.
* <code>paginationLinks</code> - a list <code>Page</code> instances that are used to render the pagination links.</p>

<p>
``` html table/page.hbs</p>

<table class="table table-condensed">
  <thead>
    {{#each column in columnHeaders}}
      <th>
        <p>{{column}}</p>
      </th>
    {{/each}}
  </thead>
  <tbody>
  {{#each row in rows}}

    {{#if row.partitionKeyChanged}}
      <tr class="partition-key-row">
        <td></td>
        <td colspan="2">
          <h3>{{row.PartitionKey}}</h3>
        </td>
        <td>
          <p class="text-right">
            <small>PARTITION KEY</small>
          </p>
        </td>
      </tr>    
    {{/if}}
  
    <tr 
      {{action "toggleRowSelection" row on="click"}} 
      {{bindAttr class=":master-row row.isSelected:master-row-selected"}}
    >
      <td>
        {{view Ember.Checkbox checkedBinding="row.isSelected" bubbles=false}}
      </td>
      {{#each column in ../columns}}
        <td>
          <p>
            {{tableCell ../row}}
          </p>
        </td>
      {{/each}}
    </tr>
  {{/each}}

  </tbody>
</table>




<div class="pagination">
  <ul>
    {{#each pageLink in paginationLinks}}
    <li {{bindAttr class="pageLink.isActive:active pageLink.disabled"}}>
        {{#unless pageLink.disabled}}
          {{#linkTo table.page pageLink}}
            {{safeString pageLink.displayText}}
          {{/linkTo}}
        {{/unless}}

        {{#if pageLink.disabled}}
          <span class="disabled">{{safeString pageLink.displayText}}</span>
        {{/if}}
    </li>
    {{/each}}
  </ul>
</div>


<p>```
</p>

<p>The template above uses a customised version of <code>Ember.CheckBox</code> and also a custom Handlebars helper <code>tableCell</code>.</p>

<p>In the template the user is allowed to toggle row selection by either checking the "isSelected" checkbox or by just clicking on the row itself. The problem with the standard <code>Ember.CheckBox</code> is that there is no way to stop the click event from bubbling up and subsequently triggering the <code>toggleRowSelection</code> action. The customised version below has an extra "bubbles" property which when set to false will disable click event propagation.</p>

<p>``` javascript EmberCheckbox.js
Ember.Checkbox = Ember.View.extend({
  classNames: ["ember-checkbox"],</p>

<p>  tagName: "input",</p>

<p>  attributeBindings: ["type", "checked", "indeterminate", "disabled", "tabindex", "name"],</p>

<p>  type: "checkbox",
  checked: false,
  disabled: false,
  indeterminate: false,
  bubbles: true,</p>

<p>  init: function() {</p>

<pre><code>this._super();
this.on("change", this, this._updateElementValue);
</code></pre>

<p>  },</p>

<p>  didInsertElement: function() {</p>

<pre><code>this._super();
this.get("element").indeterminate = !!this.get("indeterminate");

if (!this.get("bubbles")) {
  this.$().click(function(e) {
    e.stopPropagation();
  });
}
</code></pre>

<p>  },</p>

<p>  _updateElementValue: function() {</p>

<pre><code>Ember.set(this, "checked", this.$().prop("checked"));
</code></pre>

<p>  }
});
```</p>

<p>The other custom item used by the template is a Handlebars helper which is used to specific values for each of the display columns within the row. If the value is a valid date then it is formatted using the <a href="http://momentjs.com/">moment.js</a> library.
``` javascript
Ember.Handlebars.helper("tableCell", function(row, column) {
  var value = "",</p>

<pre><code>columnName = column.data.keywords.column;
</code></pre>

<p>  if (row[columnName]) {</p>

<pre><code>value = row[columnName];
</code></pre>

<p>  }</p>

<p>  if (moment(value).isValid()) {</p>

<pre><code>value = moment(value).calendar();
</code></pre>

<p>  }</p>

<p>  return value;
});
```</p>

<p>The final items to look at are the controller and template for selected items. As shown above the <code>TablePageRoute</code> renders this into the <code>selectedRowsOutlet</code> of the <code>tables.hbs</code>.</p>

<p>``` javascript SelectedRowsController.js
App.SelectedRowsController = Ember.ObjectController.extend({
  tablePage: null,
  needs: "tablePage",
  tablePageBinding: "controllers.tablePage",
  currentIndex: 0,</p>

<p>  selectedRows: function() {</p>

<pre><code>var rows = this.get("tablePage").get("rows"),
  selectedRows = _.where(rows, {isSelected: true});

if (selectedRows.length &lt;= this.get("currentIndex") &amp;&amp; selectedRows.length &gt; 0) {
  this.set("currentIndex", selectedRows.length - 1);
}

return selectedRows;
</code></pre>

<p>  }.property("tablePage.rows.@each.isSelected"),</p>

<p>  hasSelectedRows: function() {</p>

<pre><code>return (this.get("selectedRows").length &gt; 0);
</code></pre>

<p>  }.property("selectedRows"),</p>

<p>  moveNext: function() {</p>

<pre><code>var currentIndex = this.get("currentIndex");

if (currentIndex &lt; (this.get("selectedRows").length - 1)) {
  this.set("currentIndex", currentIndex + 1);
}
</code></pre>

<p>  },</p>

<p>  movePrevious: function() {</p>

<pre><code>var currentIndex = this.get("currentIndex");

if (currentIndex &gt; 0) {
  this.set("currentIndex", currentIndex - 1);
}
</code></pre>

<p>  },</p>

<p>  moveNextEnabled: function() {</p>

<pre><code>return (this.get("currentIndex") &lt; (this.get("selectedRows").length) - 1);
</code></pre>

<p>  }.property("currentIndex", "selectedRows"),</p>

<p>  movePreviousEnabled: function() {</p>

<pre><code>return (this.get("currentIndex") &gt; 0);
</code></pre>

<p>  }.property("currentIndex"),</p>

<p>  currentRow: function() {</p>

<pre><code>return this.get("selectedRows")[this.get("currentIndex")];
</code></pre>

<p>  }.property("selectedRows", "currentIndex"),</p>

<p>  currentDisplayIndex: function() {</p>

<pre><code>return this.get("currentIndex") + 1;
</code></pre>

<p>  }.property("currentIndex")</p>

<p>});
```
* <code>tablePage</code> - we have a dependency on the table page controller, Ember will wire up a reference to this property.
* <code>needs</code> - defines <code>tablePage</code> as a dependency.
* <code>tablePageBinding</code> - sets the binding that will be used to wire <code>tablePage</code>.
* <code>currentIndex</code> - the index of the record being displayed.
* <code>selectedRows</code> - a list of all the rows that are currently selected on the table details page.
* <code>hasSelectedRows</code> - true/false if there are any selected rows.
* <code>moveNext</code> - displays the next selected record.
* <code>movePrevious</code> - displays the previous selected record.
* <code>moveNextEnabled</code> - true/false if there is another record to display.
* <code>movePreviousEnabled</code> - true/false if there is a previous record to display.
* <code>currentRow</code> - the current record.
* <code>currentDisplayIndex</code> - the index of the current record as displayed to the user.</p>

<p>
``` html table/selectedRows.hbs</p>

<p>&nbsp;</p>


<ul {{bindAttr class=":nav :nav-list hasSelectedRows:show:hide"}}>
    <li class="nav-header">
       <span>ROW DETAILS</span>
       <span>({{currentDisplayIndex}}/{{selectedRows.length}})</span>
       <span class="pull-right">
           <i {{action "movePrevious" on="click"}} {{bindAttr class=":icon-btn :icon :icon-chevron-left movePreviousEnabled:enabled:disabled"}}></i>
           <i {{action "moveNext" on="click"}} {{bindAttr class=":icon-btn :icon :icon-chevron-right moveNextEnabled:enabled:disabled"}}></i>
       </span>
    </li>
    <li>
       {{#with currentRow}}
        <small>
            <p>
              <strong>ID</strong>
              <br/>
              {{input type="text" value=_.id disabled=true}}
            </p>
            <p>
              <strong>Timestamp</strong>
              <br/>
              <span>{{Timestamp}}</span>
            </p>
            <p>
              <strong>Link</strong>
              <br/>
              {{input type="text" value=_.link disabled=true}}
            </p>
            <p>
              <strong>Updated</strong>
              <br/>
              <span>{{_.updated}}</span>
            </p>
            <p>
              <strong>ETag</strong>
              <br/>
              <span>{{_.etag}}</span>
            </p>
        </small>
        {{/with}}
    </li>
</ul>


<p>```
</p>

<h4>Look ma, no unit tests!</h4>

<p>So that's enough for this morning, it's not quite fully complete but getting there. Yes there aren't any unit tests, I suck. Also I haven't implemented the record deletion seen in Jeff's app and there is also a problem with URLs regarding pagination.</p>

<p>One of the core tenants of Ember is that you should be able to reload an app or share a link with someone and be able get back to exactly that point within the application. As they say this is one of the great things about the web and a major advantage we have over native applications.</p>

<p>Due to the way paging works on Azure tables it isn't possible to restore the application back to particular page based on the URL structure I have in place. I could always embed the continuation tokens within the URL or come up with a workaround but that's for another day.</p>

<ul>
<li>The source for the app is here <a href="http://github.com/ronnieDrew/azure-table-explorer">http://github.com/ronnieDrew/azure-table-explorer</a></li>
<li>And a live version is on Azure websites <a href="https://ember-waztable.azurewebsites.net">https://ember-waztable.azurewebsites.net</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
